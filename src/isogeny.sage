# Import Sage
from sage.all import *

# Turn off arithmetic proof
proof.arithmetic(False)

def PointIsogeny(E, R_list, points=[], degrees_list=[]):
    """
        The last element, R, in R_list must have order 
            - case EVEN, either two
            - case ODD,  or some odd number (prime or not)
        The degrees list has or does not have the parallel information about the orders 
        of the points in the R_list. If no information is available, the code will
        try to compute it.

        We then construct the corresponding isogeny phi *at point level*.
        E must be an elliptic curve in short Weierstrass form.
        E  :: y^2 = x^3 + a*x + b

        CASE EVEN: R = (s,0) has order two, and s is defined in this way.
        CASE ODD : R has two components, we will build the group generated by R.

        We construct ad-hoc the isogeny map phi at point level following Section 3 of
        https://arxiv.org/pdf/math/0404124.pdf

        This gives a wonderful unifying description, that i missed in other sources.
        (It is best suited for a computer implementation (for the case of a cyclic kernel isogeny).)

        We get a map (x,y) -> phi(x,y) = X, Y.
        The article gives an unifying way to look at X-component for both even and odd torsion cases.
        The mention of the Y-component in loc. cit., simply obtained by differentiating
        the formula for X w.r.t. x.
    """

    if not R_list:
        return (E, R_list, points)

    R = R_list.pop()    # R is extracted from the last element of R_list.

    if degrees_list:
        d = degrees_list.pop()
    else:
        d = R.order()    # We have to manually compute the order.

    kernel = [k*R for k in [0..(d-1)]]
    if d*R != E(0) or len([kR for kR in kernel if kR == E(0)]) > 1:
        raise TypeError("There is no %s-torsion point." % str(d)) # We insist to have order exactly d.

    # Case even: R is a 2-torsion point
    if d == 2:
        a, b = E.a4(), E.a6()
        s = R.xy()[0]
        t = 3*s^2 + a
        w = s*t

        EE = EllipticCurve(E.base_field(), [a - 5*t, b - 7*w])

        def phi(P):
            """
                Given P, a point on E, we return a point on EE.
            """
            if P in (E(0), R):
                return EE(0)

            x, y = P.xy()
            X = x + t / (x - s)
            Y = y * (1 - t / (x - s)^2)

            return EE.point((X, Y))

    elif not 2.divides(d):
        F = E.base_field()
        a4, a6 = E.a4(), E.a6()
        b2, b4, b6 = E.b2(), E.b4(), E.b6()
        t, u, w = F(0), F(0), F(0)
        data = []

        d1 = ZZ((d - 1) / 2)
        for P in kernel[1 : d1 + 1]:
            # We split the set G = R, 2R, ... , (d-2)R, (d-1)R in two, G(+)
            # and G(-) so that P in G(+) <=> -P in G(-), the multiplicities
            # above correspond to those for G(+).
            xP , yP = P.xy()
            tP = 6*xP^2 + b2*xP + b4
            uP = 4*xP^3 + b2*xP^2 + 2*b4*xP + b6
            wP = uP + xP * tP

            t += tP
            u += uP
            w += wP

            data.append([xP, yP, tP, uP])

        EE = EllipticCurve(F, [a4 - 5*t, a6 - b2*t - 7*w])

        def phi(point):
            if point in kernel:
                return EE(0)

            x, y = point.xy()
            X, Y = x, y

            for xP, yP, tP, uP in data:
                X +=       tP / (x - xP)   + uP   / (x - xP)^2
                Y += y * (-tP / (x - xP)^2 - uP*2 / (x - xP)^3)    # y * diff(xx, x)

            return EE((X, Y))

    else:
        # Torsion point of order 4, 6, 8, etc.
        raise TypeError("Argument degree (= %s) should be either an odd number or 2." % str(d))

    return (EE
           ,[phi(P) for P in R_list]
           ,[phi(P) for P in points]
           ,degrees_list)
